#ЧАСТЬ 1

#? Найти количество пар элементов сумма которых чётна.
# from random import randint
# a = [randint(0, 10) for _ in range(5)]
# print(a)
# k = k0 = k1 = 0
# for x in a:
#     if x % 2 == 0:
#         k += k0
#         k0 += 1
#     else:
#         k += k1
#         k1 += 1
# print(k)

#? Гоночная трасса состоит из двух основных дорог и нескольких переездов, позволяющих
# перейти с одной дороги на другую.
# На всех участках, включая переезды, движение разрешено только в одну сторону, поэтому
# переезд возможен только с дороги A на дорогу B. Гонщик стартует в точке A0 и должен
# финишировать в точке BN. Он знает, за какое время сможет пройти каждый участок пути по
# каждой дороге, то есть время прохождения участков A0A1, A1A2, ..., AN-1AN, B0B1, B1B2, ..., BN-1BN.
# Время прохождения всех переездов A0B0, A1B1, ..., ANBN одинаково и известно гонщику.
# Необходимо определить, за какое минимальное время гонщик сможет пройти трассу.

# import random
# n = 4
# a = [random.randint(1,10) for i in range(n)]
# b = [random.randint(1, 10) for i in range(n)]
#
# dt = random.randint(1,10)
# #1
# ans = 10 ** 9
# for i in range(n + 1):
#     t = sum(a[:i]) + dt + sum(b[i:]) #O(N**2) из-за суммы
#     ans = min(t, ans)
# print(ans)
# #2
# ta = 0 #трасса А
# tb = 0 #трасса B
# for i in range(n):
#     x, y = a[i], b[i]
#     ta += x
#     tb = min(tb + y, ta + dt)
# print(tb)

#? Дана последовательность из N натуральных чисел. Рассматриваются все её непрерывные
# подпоследовательности, такие что сумма элементов каждой из них кратна k = 43. Найдите среди них
# подпоследовательность с максимальной суммой, определите её длину. Если таких
# подпоследовательностей найдено несколько, в ответе укажите количество элементов самой короткой из
# них.
# Входные данные
# Даны два входных файла (файл A и файл B), каждый из которых содержит в первой строке количество N (1 ≤ N
# ≤ 108). Каждая из следующих N строк содержит одно натуральное число, не превышающих 10000.
# Пример организации исходных данных во входном файле:
# 7
# 21
# 13
# 9
# 19
# 17
# 26
# 95
# В этом наборе можно выбрать последовательности 21+13+9 (сумма 43) и 17+26 (сумма 43). Самая короткая из
# них, 17 + 26, имеет длину 2. Для указанных программа должна вывести число 2.
# В ответе укажите два числа: сначала значение искомой длины для файла А, затем для файла B.

# import sys
# # sys.stdin = open('27_A.txt') #27t.txt
# sys.stdin = open('27_B.txt')
#
# n = int(input())
# a = []
# for i in range(n):
#     a.append(int(input()))
# ans = n + 1
# maxS = -1
#1
# for i in range(n):
#     for j in range(i,n): #отрезок i - j
#         cur = 0         #считаем сумму отрезка
#         for k in range(i, j + 1):       #O(N^3)
#             cur += a[k]
#             if cur % 43 == 0:
#                 if cur > maxS:
#                     maxS = cur
#                     ans = j - i + 1
#                 elif cur == maxS:
#                     ans = min(ans, j - i + 1)
#2
# pre = [0]
# for i in a:
#     pre.append(pre[-1] + i)
# for i in range(n):
#     for j in range(i, n):  #O(N^2)
#         cur = pre[j] - pre[i]
#         if cur % 43 == 0:
#             if cur > maxS:
#                 maxS = cur
#                 ans = j - i + 1
#             elif cur == maxS:
#                 ans = min(ans, j - i)
#3
# pre = [0] + [False] * 42
# pre_ind = [0] * 43
# total = 0
# for i in range(n):
#     total += a[i]
#     mod = total % 43
#     if pre[mod]:
#         cur = total - pre[mod]
#         if cur > maxS:
#             maxS = cur
#             ans = i - pre_ind[mod]
#         elif cur == maxS:
#             ans = min(ans, i - pre_ind[mod])
#     else:
#         pre[mod] = total
#         pre_ind[mod] = i
# print(ans)







#ЧАСТЬ 2

#? Для заданной последовательности неотрицательных целых чисел необходимо найти
# максимальное произведение двух её элементов, номера которых различаются не менее чем на
# 8. Значение каждого элемента последовательности не превышает 1000. Количество элементов
# последовательности не превышает 10000.
# Задача А. Напишите на любом языке программирования программу для решения поставленной
# задачи, в которой входные данные будут запоминаться в массиве, после чего будут проверены
# все возможные пары элементов.
# Задача Б. Напишите программу для решения поставленной задачи, которая будет эффективна
# как по времени, так и по памяти (или хотя бы по одной из этих характеристик).
# Пример входных данных:
# 10
# 100
# 45
# 55
# 245
# 35
# 25
# 10
# 10
# 10
# 26
# Программа должна вывести одно число – описанное в условии произведение.
# Пример выходных данных для приведённого выше примера входных данных:
# 2600

# import sys
# sys.stdin = open('kurs27-step8.txt')

# #A
# n = int(input())
# a = []
# for i in range(n):
#     a.append(int(input()))
#
# ans = - 1
# for i in range(n - 8):
#     for j in range(i + 8, n):
#         ans = max(ans, a[i] * a[j])
# print(ans)

# #B - буфаризация - типа запоминаем только 8 элементов
# n = int(input())
# buf = []
# for i in range(8):
#     buf.append(int(input()))
# max_x = ans = -1
# for i in range(n-8):
#     y = int(input())
#     x = buf.pop(0)
#     max_x = max(max_x, x)
#     ans = max(ans, y * max_x)
#     buf.append(y)
# print(ans)

#? На спутнике «Восход» установлен прибор, предназначенный для измерения солнечной
# активности. Каждую минуту прибор передаёт по каналу связи натуральное число – количество
# энергии солнечного излучения, полученной за последнюю минуту, измеренное в условных
# единицах. Временем, в течение которого происходит передача, можно пренебречь.
# Необходимо найти в заданной серии количество пар таких показаний прибора, произведение
# которых кратно 6 и между моментами передачи которых прошло не менее 3 минут.
# Количество энергии, получаемое прибором за минуту, не превышает 1000 условных единиц.
# Общее количество показаний прибора в серии не превышает 10 000.
# Задача А. Напишите как-нибудь
# Задача Б. Эффективную программу

# import sys
# sys.stdin = open('kurs27-sputnik.txt')

# #A
# n = int(input())
# a = []
# for i in range(n):
#     a.append(int(input()))
# ans = 0
# for i in range(n - 3):
#     for j in range(i + 3, n):
#         if a[i] * a[j] % 6 == 0:
#             ans += 1
# print(ans)

# #B
# n = int(input())
# n1 = n2 = n3 = n6 = 0
# ans = 0
# q = []
# for i in range(3):
#     q.append(int(input()))
# for i in range(n - 3):
#     x = q.pop(0)
#     if x % 6 == 0:
#         n6 += 1
#     elif x % 3 == 0:
#         n3 += 1
#     elif x % 2 == 0:
#         n2 += 1
#     else:
#         n1 += 1
#     y = int(input())
#     q.append(y)
#     if y % 6 == 0:
#         ans += n6 + n1 + n2 + n3
#     elif y % 3 == 0:
#         ans += n6 + n2
#     elif y % 2 == 0:
#         ans += n6 + n3
#     else:
#         ans += n6
# print(ans)

# На автомобильной кольцевой дороге с движением в обе стороны
# через каждый километр расположен мусорный контейнер.
# Всего расположено N контейнеров.
#
# Каждый такой мусорный контейнер обслуживается отдельной мусоровозной машиной.
# Необходимо вывезти мусор из всех контейнеров, доставив его на перерабатывающий завод.
# Перерабатывающий завод можно расположить на любой из точек расположения мусорных контейнеров.
# Стоимость транспортировки мусора от контейнера до завода рассчитывается
# как расстояние от контейнера до перерабатывающего завода,
# умноженное на количество мусора в этом контейнере.
# Если перерабатывающий завод находится в той же точке с мусорным контейнером,
# то расстояние от этой точки считается равным нулю.
# Необходимо определить, рядом с каким контейнером следует разместить перерабатывающий завод,
# чтобы стоимость транспортировки мусора от остальных контейнеров была минимальной.
#
# Описание входных данных:
# Первое число N - количество контейнеров для мусора.
# Последующие N чисел - количество условных единиц мусора,
# которое находится на соответствующей точке.
# Описание выходных данных:
# Необходимо вывести одно натуральное число - номер контейнера,
# рядом с которым нужно расположить перерабатывающий завод,
# чтобы стоимость транспортировки мусора от остальных контейнеров была минимальной для файла А и для файла В в поля ниже.
# Контейнеры нумеруются от 1 до N.
# Пример организации входных данных:
# 6
# 8
# 20
# 5
# 13
# 7
# 19
# Ответ для приведённого примера:
# 6 (19 * 0 + 7 * 1 + 8 * 1 + 13 * 2 + 20 * 2 + 5 * 3).

# import sys
# sys.stdin = open('zadanieA277192.txt')
# # sys.stdin = open('zadanieB277192.txt') #z27.txt
#
# n = int(input())
# a = []
# for i in range(n):
#     a.append(int(input()))

# #A
# INF = 10 ** 12
# min_p = INF
# for i in range(n):
#     p = 0
#     for j in range(n):
#         p += a[j] * min(abs(j-i), n - abs(j - i)) #Короткое расстояние
#     if p < min_p: #Самый хороший контейнер
#         min_p = p
#         ans = i + 1
# print(ans)

# #B
# ccw = sum(a[:(n + 1) // 2]) #поедет против часовой из первого пункта
# cw = sum(a[(n + 1) // 2 :]) #поедет по часовой из первого пункта
# p = 0
# for j in range(n):
#     p += a[j] * min(j, n - j)
# min_p = p #price
# ans = 0 #Пока самый лучший пункт
# for i in range(n):
#     ccw = ccw - a[i] + a[((n + 1) // 2 + i) % n]
#     cw = cw + a[i] - a[((n + 1) // 2 + i) % n]
#     p = p - ccw + cw
#     if p < min_p:
#         min_p = p
#         ans = i + 1
# print(ans + 1)

# Молокозавод доставляет свою продукцию в N торговых точек.
# Все торговые точки расположены вдоль дороги и имеют номера, соответствующие
# расстоянию от нулевой отметки до магазина.
# Известно количество пакетов молока, которое ежедневно доставляется в каждый из магазинов.Пакеты
# перевозят в ящиках вместимостью не более 45 штук.
# Каждый ящик маркируется перед отправлением и предназначен для определенной торговой
# точки, перевозить в одном ящике продукцию для нескольких торговых точек нельзя.
# Стоимость перевозки продукции равна произведению расстояния от оптового склада
# до торговой точки на количество ящиков.
# Общая стоимость перевозки за день равна сумме стоимостей перевозок от склада до каждого магазина.Оптовый
# склад будет расположен рядом с одной из торговых точек таким образом, чтобы
# общая стоимость доставки всей продукции была минимальна.
# Определите минимальную общую стоимость доставки продукции от оптового склада до всех магазинов.
# Входные данные
# Дано два входных файла (файл A и файл B),
# каждый из которых в первой строке содержит число
# N (1 ≤ N ≤ 10 000 000) – количество торговых точек.
# В каждой из следующих N строк находится два числа:
# номер магазина и количество пакетов, отправляемых в этот магазин
# (все числа натуральные, количество пакетов для одного магазина
# не превышает 1000).
# Магазины перечислены в порядке их расположения вдоль дороги,
# начиная от нулевой отметки.
# В ответе укажите два числа: сначала значение искомой величины для файла А,
# затем – для файла B.
#
# 6
# 1 150
# 2 140
# 7 15
# 8 31
# 9 12
# 10 190
# При таких исходных данных и вместимости ящика, составляющей 50 пакетов,
# заводу выгодно расположить склад рядом с магазином 3.
# В этом случае сумма транспортных затрат составит:
# 6 ∙ 3 + 5 ∙ 3 + 1 ∙ 1 + 2 ∙ 1 + 3 ∙ 4 = 48.

# import sys
# # sys.stdin = open('z27_A.txt')
# sys.stdin = open('z27_B.txt')
# # sys.stdin = open('xp27.txt')
#
# n = int(input())
# a = []
# v = 45 #В примере 50, в задаче 45
# for i in range(n):
#     x, y = map(int, input().split())
#     a.append([x, (y - 1) // v + 1])

# #A
# ans = 10 ** 12
# for i in range(n):
#     p = 0
#     for j in range(n):
#         p += abs(a[j][0] - a[i][0]) * a[j][1]
#     ans = min(ans, p)
# print(ans)

# #B
# pre = [0]
# for i in range(n):
#     pre.append(pre[-1] + a[i][1])
#
# res = 0
# for i in range(n):
#     res += a[i][1] * (a[i][0] - a[0][0]) #Price
#
# ans = res
# for i in range(1, n):
#     d = a[i][0] - a[i - 1][0]
#     res = res + pre[i] * d - (pre[-1] - pre[i]) * d #Стоимость
#     ans = min(ans, res)
# print(ans)

#?DOP27
#В физической лаборатории проводится долговременный эксперимент
# по изучению гравитационного поля Земли.
# По каналу связи каждую минуту в лабораторию передаётся положительное
# целое число – текущее показание прибора «Сигма 2015».
# Количество передаваемых чисел в серии известно и не превышает 10 000.
# Все числа не превышают 1000. Временем, в течение которого происходит передача, можно пренебречь.

#Необходимо вычислить «бета-значение» серии показаний
# прибора – минимальное чётное произведение двух показаний,
# между моментами передачи которых прошло не менее 6 минут.
# Если получить такое произведение не удаётся, ответ считается равным –1.

#Вам предлагается два файла, связанных с этой задачей: задание А и задание Б.
# Вы можете решать оба задания или одно из них по своему выбору.

#А. Напишите на любом языке программирования программу для решения поставленной задачи,
# в которой входные данные будут запоминаться в массиве,
# после чего будут проверены все возможные пары элементов.

#Б. Напишите программу для решения поставленной задачи,
# которая будет эффективна как по времени, так и по памяти
# (или хотя бы по одной из этих характеристик).
# Программа считается эффективной по времени,
# если время работы программы пропорционально количеству полученных показаний прибора N,
# т.е. при увеличении N в k раз время работы программы должно увеличиваться
# не более чем в k раз.
# Программа считается эффективной по памяти, если размер памяти,
# использованной в программе для хранения данных,
# не зависит от числа N и не превышает 1 килобайта.
# 11
# 12
# 45
# 5
# 3
# 17
# 23
# 21
# 20
# 19
# 18
# 17
#Программа должна вывести одно число – описанное в условии произведение либо –1,
# если получить такое произведение не удаётся.
# Пример выходных данных для приведённого выше примера входных данных: 54

# import sys
# #sys.stdin = open('dop27.txt')
# #sys.stdin = open('a.txt')
# sys.stdin = open('b.txt')
#
# n = int(input())
# buf = []
# for i in range(6):
#     buf.append(int(input()))
#
# minEven = minOdd = ans = 10 ** 9
# for i in range(n - 6):
#     x = int(input())
#     y = buf.pop(0)
#     if y % 2 == 0:
#         minEven = min(minEven, y)
#     else:
#         minOdd = min(minOdd, y)
#     if x % 2 == 0:
#         ans = min(ans, x * minOdd, x * minEven)
#     else:
#         ans = min(ans, x * minEven)
#     buf.append(x)
# print(ans)





